<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="./assets/styles/reset.css">
  <link rel="stylesheet" href="./assets/styles/variables.css">
  <link rel="stylesheet" href="./assets/styles/header.css">
  <link rel="stylesheet" href="./assets/styles/theory.css">
  <title>Theory</title>
</head>

<body>
  <div id="header"></div>
  <div id="theory"></div>

  <div class="theory-container">
    <div class="content">
    <!-- theory here -->
    <!-- aside -->
      <!-- theories block 1-->

      <!-- end theory block -->
      <!-- theories block 2 -->
      <div class="content-anchor" id="Generators">
        <div class="container">
          <h2>Frequently Asked Questions</h2>
          <div class="accordion">
            <div class="accordion-item">
              <button id="accordion-button-1" aria-expanded="false"><span class="accordion-title">Инициализация
                  объектов</span><span class="icon" aria-hidden="true"></span></button>
              <div class="accordion-content">
                <ul>
                  <li><a href="#one">one</a></li>
                  <li><a href="#two">two</a></li>
                  <li><a href="#thr">thr</a></li>
                </ul>
                <p>Объекты могут быть инициализированы с помощью new Object(), Object.create() или литеральной
                  (инициирующей) нотации. Инициализатор объекта это разделённый запятыми список ноль или более пар имён
                  свойств и ассоциируемых с ними значений, заключённых в фигурные скобки ({}).
                  <div id="one">
                    Синтаксис
                    var o = {};
                    var o = {a: 'foo', b: 42, c: {}};

                    var a = 'foo', b = 42, c = {};
                    var o = {a: a, b: b, c: c};

                    var o = {
                    property: function ([parameters]) {},
                    get property() {},
                    set property(value) {}
                    };
                  </div>
                  Copy to Clipboard
                  Новая нотация в ECMAScript 2015
                  Пожалуйста, просмотрите таблицу поддержки этих нотаций. В неподдерживаемом окружении, эти нотации
                  приведут
                  к синтаксической ошибке.
                  <div>
                    <pre><code>
              // Сокращение имён свойств (ES2015)
              var a = 'foo', b = 42, c = {};
              var o = {a, b, c};

              // Сокращение имён методов (ES2015)
              var o = {
                property([parameters]) {}
              };
            </code></pre>
                  </div>
                  <pre><code>

              // Вычисление имён свойств (ES2015)
              var prop = 'foo';
              var o = {
                [prop]: 'hey',
                ['b' + 'ar']: 'there'
              };
            </code></pre>

                 
               
                  
                 
  
                  Создание объектов
                  Пустой объект без свойств может быть создан следующим образом:
                  <div>
                    var object = {};
                    Copy to Clipboard
                    Однако, преимущество литеральной или инициирующей нотации это возможность быстро создавать объекты
                    со
                    свойствами внутри фигурных скобок. Создаётся простой список пар ключ: значение, разделённых запятой.
                    Следующий код создаёт объект с тремя парами значений и ключи это "foo", "age" и "baz". Значения этих
                    ключей строка "bar", число 42 и другой объект.

                    var object = {
                    foo: 'bar',
                    age: 42,
                    baz: {myProp: 12}
                    }
                  </div>
                  Copy to Clipboard
                  Доступность свойств
                  После того, как создали объект, вы, вероятно, захотите прочитать или изменить его. Свойства объектов
                  могут
                  быть получены при помощи точечной нотации или квадратных скобок. Смотрите property accessors для
                  детальной
                  информации.

                  object.foo; // "bar"
                  object['age']; // 42

                  object.foo = 'baz';
                  Copy to Clipboard
                  Определение свойств
                  Мы уже рассмотрели, как объявить свойства, используя синтаксис инициализации. Зачастую, в коде
                  появляются
                  свойства, которые вы захотите поместить в объект. Вы увидите следующий код:

                  var a = 'foo',
                  b = 42,
                  c = {};

                  var o = {
                  a: a,
                  b: b,
                  c: c
                  };
                  Copy to Clipboard
                  С ECMAScript 2015 появилась короткая нотация, способная достичь того же:

                  var a = 'foo',
                  b = 42,
                  c = {};

                  // Сокращение имён свойств (ES2015)
                  var o = {a, b, c};

                  // Иначе говоря,
                  console.log((o.a === {a}.a)); // true
                  Copy to Clipboard
                  Повторение имён свойств
                  Когда используются одинаковые имена свойств, второе свойство перезапишет первое.

                  var a = {x: 1, x: 2};
                  console.log(a); // {x: 2}
                  Copy to Clipboard
                  В строгом режиме ECMAScript 5, повторение имён свойств будет воспринято как SyntaxError. С введением
                  вычисляемых имён свойств и появлением возможности создавать дубликаты во время выполнения кода,
                  ECMAScript
                  2015 убрал это ограничение.

                  function haveES2015DuplicatePropertySemantics() {
                  'use strict';
                  try {
                  ({prop: 1, prop: 2});

                  // Не будет ошибки, повторение имён доступно в строгом режиме
                  return true;
                  } catch(e) {
                  // Будет ошибка, дубликаты запрещены в строгом режиме
                  return false;
                  }
                  }
                  Copy to Clipboard
                  <div id="two">
                    Описание методов
                    Свойство объекта также может ссылаться на function, getter или setter.
                  </div>
                  var o = {
                  property: function ([parameters]) {},
                  get property() {},
                  set property(value) {}
                  };
                  Copy to Clipboard
                  В ECMAScript 2015, доступна короткая нотация, поэтому слово "function" более не обязательно.

                  // Сокращение имён методов (ES2015)
                  var o = {
                  property([parameters]) {},
                  *generator() {}
                  };
                  Copy to Clipboard
                  В ECMAScript 2015 есть способ кратко объявить свойства, чьими значениями являются генераторы функций:

                  var o = {
                  *generator() {
                  ...........
                  }
                  };
                  Copy to Clipboard
                  Что эквивалентно следующей ES5-подобной нотации (но отметьте, что ECMAScript 5 не содержит
                  генераторов):

                  var o = {
                  generator: function* () {
                  ...........
                  }
                  };
                  Copy to Clipboard
                  Для большей информации и примеров смотри method definitions.

                  Вычисляемые имена свойств
                  Начиная с ECMAScript 2015, синтаксис объявления объектов также поддерживает вычисляемые имена свойств.
                  Это
                  позволяет добавлять в скобки [] выражение, которое будет вычислено, как имя свойства. Это похоже на
                  скобочную нотацию синтаксиса property accessor, которую вы, вероятно, уже использовали, чтобы
                  прочитать и
                  задать свойство. Теперь можно использовать аналогичный способ с литеральными объектами:

                  // Вычисляемое имя свойства (ES2015)
                  var i = 0;
                  var a = {
                  ['foo' + ++i]: i,
                  ['foo' + ++i]: i,
                  ['foo' + ++i]: i
                  };

                  console.log(a.foo1); // 1
                  console.log(a.foo2); // 2
                  console.log(a.foo3); // 3

                  var param = 'size';
                  var config = {
                  [param]: 12,
                  ['mobile' + param.charAt(0).toUpperCase() + param.slice(1)]: 4
                  };

                  console.log(config); // {size: 12, mobileSize: 4}
                  Copy to Clipboard
                  Spread-свойства
                  Rest/Spread свойство ECMAScript предлагает (stage 3) добавлять spread свойства в литеральную нотацию.
                  Оно
                  копирует собственные перечисляемые свойства из представленного объекта в новый.

                  Поверхностное копирование (исключая prototype) или слияние объектов теперь возможно с помощью более
                  короткого синтаксиса, чем Object.assign().

                  var obj1 = { foo: 'bar', x: 42 };
                  var obj2 = { foo: 'baz', y: 13 };

                  var clonedObj = { ...obj1 };
                  // Объект { foo: "bar", x: 42 }

                  var mergedObj = { ...obj1, ...obj2 };
                  // Объект { foo: "baz", x: 42, y: 13 }
                  Copy to Clipboard
                  Заметьте, что Object.assign() вызывает setters, тогда как оператор spread нет.

                  <div id="thr">
                    Изменение Prototype
                    Объявление свойства в виде __proto__: value или "__proto__": value не создаст свойства с именем
                    __proto__. Вместо этого, если предоставляемое значение объект или null, оно заменит [[Prototype]]
                    создаваемого объекта на это значение. (Если значение не объект или null, объект не изменится.)
                  </div>
                  var obj1 = {};
                  assert(Object.getPrototypeOf(obj1) === Object.prototype);

                  var obj2 = {__proto__: null};
                  assert(Object.getPrototypeOf(obj2) === null);

                  var protoObj = {};
                  var obj3 = {'__proto__': protoObj};
                  assert(Object.getPrototypeOf(obj3) === protoObj);

                  var obj4 = {__proto__: 'not an object or null'};
                  assert(Object.getPrototypeOf(obj4) === Object.prototype);
                  assert(!obj4.hasOwnProperty('__proto__'));
                  Copy to Clipboard
                  Только одно изменение prototype разрешено через литеральное объявление объекта: несколько изменений
                  prototype вызовут синтаксическую ошибку.

                  Объявление свойства не через "двоеточие" не изменит значения prototype: это описание будет выглядеть
                  идентично такому же объявлению свойства с использованием любого другого имени.

                  var __proto__ = 'variable';

                  var obj1 = {__proto__};
                  assert(Object.getPrototypeOf(obj1) === Object.prototype);
                  assert(obj1.hasOwnProperty('__proto__'));
                  assert(obj1.__proto__ === 'variable');

                  var obj2 = {__proto__() { return 'hello'; }};
                  assert(obj2.__proto__() === 'hello');

                  var obj3 = {['__prot' + 'o__']: 17};
                  assert(obj3.__proto__ === 17);
                  Copy to Clipboard
                  Литеральная нотация vs JSON
                  Литеральная нотация не то же самое, что и JavaScript Object Notation (JSON). Хотя они и выглядят
                  аналогично, существует разница между ними:

                  JSON позволяет объявление свойств только с помощью синтаксиса "property": value. Имя свойства должно
                  быть
                  заключено в двойные кавычки и объявление не может быть сокращено.
                  В JSON значения могут быть только строками, числами, массивами, true, false, null или другими (JSON)
                  объектами.
                  Значения-функции (смотри "Методы" выше) не м
              </div>
            </div>
            <div class="accordion-item">
              <button id="accordion-button-2" aria-expanded="false"><span
                  class="accordion-title">Конструктор</span><span class="icon" aria-hidden="true"></span></button>
              <div class="accordion-content">
                <p>Объекты могут быть инициализированы с помощью new Object(), Object.create() или литеральной
                  (инициирующей) нотации. Инициализатор объекта это разделённый запятыми список ноль или более пар имён
                  свойств и ассоциируемых с ними значений, заключённых в фигурные скобки ({}).

                  Синтаксис
                  var o = {};
                  var o = {a: 'foo', b: 42, c: {}};

                  var a = 'foo', b = 42, c = {};
                  var o = {a: a, b: b, c: c};

                  var o = {
                  property: function ([parameters]) {},
                  get property() {},
                  set property(value) {}
                  };
                  Copy to Clipboard
                  Новая нотация в ECMAScript 2015
                  Пожалуйста, просмотрите таблицу поддержки этих нотаций. В неподдерживаемом окружении, эти нотации
                  приведут
                  к синтаксической ошибке.

                  // Сокращение имён свойств (ES2015)
                  var a = 'foo', b = 42, c = {};
                  var o = {a, b, c};

                  // Сокращение имён методов (ES2015)
                  var o = {
                  property([parameters]) {}
                  };

                  // Вычисление имён свойств (ES2015)
                  var prop = 'foo';
                  var o = {
                  [prop]: 'hey',
                  ['b' + 'ar']: 'there'
                  };
                  Copy to Clipboard
                  Описание
                  Инициализатор объекта это выражение, которое описывает инициализацию Object. Объекты состоят из
                  свойств,
                  которые используются для описания объекта. Значения свойств объектов могут содержать как примитивные
                  типы
                  данных, так и другие объекты.

                  Создание объектов
                  Пустой объект без свойств может быть создан следующим образом:

                  var object = {};
                  Copy to Clipboard
                  Однако, преимущество литеральной или инициирующей нотации это возможность быстро создавать объекты со
                  свойствами внутри фигурных скобок. Создаётся простой список пар ключ: значение, разделённых запятой.
                  Следующий код создаёт объект с тремя парами значений и ключи это "foo", "age" и "baz". Значения этих
                  ключей строка "bar", число 42 и другой объект.

                  var object = {
                  foo: 'bar',
                  age: 42,
                  baz: {myProp: 12}
                  }
                  Copy to Clipboard
                  Доступность свойств
                  После того, как создали объект, вы, вероятно, захотите прочитать или изменить его. Свойства объектов
                  могут
                  быть получены при помощи точечной нотации или квадратных скобок. Смотрите property accessors для
                  детальной
                  информации.

                  object.foo; // "bar"
                  object['age']; // 42

                  object.foo = 'baz';
                  Copy to Clipboard
                  Определение свойств
                  Мы уже рассмотрели, как объявить свойства, используя синтаксис инициализации. Зачастую, в коде
                  появляются
                  свойства, которые вы захотите поместить в объект. Вы увидите следующий код:

                  var a = 'foo',
                  b = 42,
                  c = {};

                  var o = {
                  a: a,
                  b: b,
                  c: c
                  };
                  Copy to Clipboard
                  С ECMAScript 2015 появилась короткая нотация, способная достичь того же:

                  var a = 'foo',
                  b = 42,
                  c = {};

                  // Сокращение имён свойств (ES2015)
                  var o = {a, b, c};

                  // Иначе говоря,
                  console.log((o.a === {a}.a)); // true
                  Copy to Clipboard
                  Повторение имён свойств
                  Когда используются одинаковые имена свойств, второе свойство перезапишет первое.

                  var a = {x: 1, x: 2};
                  console.log(a); // {x: 2}
                  Copy to Clipboard
                  В строгом режиме ECMAScript 5, повторение имён свойств будет воспринято как SyntaxError. С введением
                  вычисляемых имён свойств и появлением возможности создавать дубликаты во время выполнения кода,
                  ECMAScript
                  2015 убрал это ограничение.

                  function haveES2015DuplicatePropertySemantics() {
                  'use strict';
                  try {
                  ({prop: 1, prop: 2});

                  // Не будет ошибки, повторение имён доступно в строгом режиме
                  return true;
                  } catch(e) {
                  // Будет ошибка, дубликаты запрещены в строгом режиме
                  return false;
                  }
                  }
                  Copy to Clipboard
                  Описание методов
                  Свойство объекта также может ссылаться на function, getter или setter.

                  var o = {
                  property: function ([parameters]) {},
                  get property() {},
                  set property(value) {}
                  };
                  Copy to Clipboard
                  В ECMAScript 2015, доступна короткая нотация, поэтому слово "function" более не обязательно.

                  // Сокращение имён методов (ES2015)
                  var o = {
                  property([parameters]) {},
                  *generator() {}
                  };
                  Copy to Clipboard
                  В ECMAScript 2015 есть способ кратко объявить свойства, чьими значениями являются генераторы функций:

                  var o = {
                  *generator() {
                  ...........
                  }
                  };
                  Copy to Clipboard
                  Что эквивалентно следующей ES5-подобной нотации (но отметьте, что ECMAScript 5 не содержит
                  генераторов):

                  var o = {
                  generator: function* () {
                  ...........
                  }
                  };
                  Copy to Clipboard
                  Для большей информации и примеров смотри method definitions.

                  Вычисляемые имена свойств
                  Начиная с ECMAScript 2015, синтаксис объявления объектов также поддерживает вычисляемые имена свойств.
                  Это
                  позволяет добавлять в скобки [] выражение, которое будет вычислено, как имя свойства. Это похоже на
                  скобочную нотацию синтаксиса property accessor, которую вы, вероятно, уже использовали, чтобы
                  прочитать и
                  задать свойство. Теперь можно использовать аналогичный способ с литеральными объектами:

                  // Вычисляемое имя свойства (ES2015)
                  var i = 0;
                  var a = {
                  ['foo' + ++i]: i,
                  ['foo' + ++i]: i,
                  ['foo' + ++i]: i
                  };

                  console.log(a.foo1); // 1
                  console.log(a.foo2); // 2
                  console.log(a.foo3); // 3

                  var param = 'size';
                  var config = {
                  [param]: 12,
                  ['mobile' + param.charAt(0).toUpperCase() + param.slice(1)]: 4
                  };

                  console.log(config); // {size: 12, mobileSize: 4}
                  Copy to Clipboard
                  Spread-свойства
                  Rest/Spread свойство ECMAScript предлагает (stage 3) добавлять spread свойства в литеральную нотацию.
                  Оно
                  копирует собственные перечисляемые свойства из представленного объекта в новый.

                  Поверхностное копирование (исключая prototype) или слияние объектов теперь возможно с помощью более
                  короткого синтаксиса, чем Object.assign().

                  var obj1 = { foo: 'bar', x: 42 };
                  var obj2 = { foo: 'baz', y: 13 };

                  var clonedObj = { ...obj1 };
                  // Объект { foo: "bar", x: 42 }

                  var mergedObj = { ...obj1, ...obj2 };
                  // Объект { foo: "baz", x: 42, y: 13 }
                  Copy to Clipboard
                  Заметьте, что Object.assign() вызывает setters, тогда как оператор spread нет.

                  Изменение Prototype
                  Объявление свойства в виде __proto__: value или "__proto__": value не создаст свойства с именем
                  __proto__.
                  Вместо этого, если предоставляемое значение объект или null, оно заменит [[Prototype]] создаваемого
                  объекта на это значение. (Если значение не объект или null, объект не изменится.)

                  var obj1 = {};
                  assert(Object.getPrototypeOf(obj1) === Object.prototype);

                  var obj2 = {__proto__: null};
                  assert(Object.getPrototypeOf(obj2) === null);

                  var protoObj = {};
                  var obj3 = {'__proto__': protoObj};
                  assert(Object.getPrototypeOf(obj3) === protoObj);

                  var obj4 = {__proto__: 'not an object or null'};
                  assert(Object.getPrototypeOf(obj4) === Object.prototype);
                  assert(!obj4.hasOwnProperty('__proto__'));
                  Copy to Clipboard
                  Только одно изменение prototype разрешено через литеральное объявление объекта: несколько изменений
                  prototype вызовут синтаксическую ошибку.

                  Объявление свойства не через "двоеточие" не изменит значения prototype: это описание будет выглядеть
                  идентично такому же объявлению свойства с использованием любого другого имени.

                  var __proto__ = 'variable';

                  var obj1 = {__proto__};
                  assert(Object.getPrototypeOf(obj1) === Object.prototype);
                  assert(obj1.hasOwnProperty('__proto__'));
                  assert(obj1.__proto__ === 'variable');

                  var obj2 = {__proto__() { return 'hello'; }};
                  assert(obj2.__proto__() === 'hello');

                  var obj3 = {['__prot' + 'o__']: 17};
                  assert(obj3.__proto__ === 17);
                  Copy to Clipboard
                  Литеральная нотация vs JSON
                  Литеральная нотация не то же самое, что и JavaScript Object Notation (JSON). Хотя они и выглядят
                  аналогично, существует разница между ними:

                  JSON позволяет объявление свойств только с помощью синтаксиса "property": value. Имя свойства должно
                  быть
                  заключено в двойные кавычки и объявление не может быть сокращено.
                  В JSON значения могут быть только строками, числами, массивами, true, false, null или другими (JSON)
                  объектами.
                  Значения-функции (смотри "Методы" выше) не м.</p>
              </div>
            </div>
            <div class="accordion-item">
              <button id="accordion-button-3" aria-expanded="false"><span class="accordion-title">Will we ever discover
                  aliens?</span><span class="icon" aria-hidden="true"></span></button>
              <div class="accordion-content">
                <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore
                  et
                  dolore magna aliqua. Elementum sagittis vitae et leo duis ut. Ut tortor pretium viverra suspendisse
                  potenti.</p>
              </div>
            </div>
          </div>
        </div>

      </div>
      <!-- end theory block 2 -->
      <!-- theories block 3-->
      <div class="content-anchor" id="Arrays">
        <div class="container">
          <h2>Frequently Asked Questions</h2>
          <div class="accordion">
            <div class="accordion-item">
              <button id="accordion-button-1" aria-expanded="false"><span class="accordion-title">Инициализация
                  объектов</span><span class="icon" aria-hidden="true"></span></button>
              <div class="accordion-content">
                <ul>
                  <li><a href="#one">one</a></li>
                  <li><a href="#two">two</a></li>
                  <li><a href="#thr">thr</a></li>
                </ul>
                <p>Объекты могут быть инициализированы с помощью new Object(), Object.create() или литеральной
                  (инициирующей) нотации. Инициализатор объекта это разделённый запятыми список ноль или более пар имён
                  свойств и ассоциируемых с ними значений, заключённых в фигурные скобки ({}).
                  <div id="one">
                    Синтаксис
                    var o = {};
                    var o = {a: 'foo', b: 42, c: {}};

                    var a = 'foo', b = 42, c = {};
                    var o = {a: a, b: b, c: c};

                    var o = {
                    property: function ([parameters]) {},
                    get property() {},
                    set property(value) {}
                    };
                  </div>
                  Copy to Clipboard
                  Новая нотация в ECMAScript 2015
                  Пожалуйста, просмотрите таблицу поддержки этих нотаций. В неподдерживаемом окружении, эти нотации
                  приведут
                  к синтаксической ошибке.
                  <div>
                    <pre><code>
              // Сокращение имён свойств (ES2015)
              var a = 'foo', b = 42, c = {};
              var o = {a, b, c};

              // Сокращение имён методов (ES2015)
              var o = {
                property([parameters]) {}
              };
            </code></pre>
                  </div>
                  <pre><code>

              // Вычисление имён свойств (ES2015)
              var prop = 'foo';
              var o = {
                [prop]: 'hey',
                ['b' + 'ar']: 'there'
              };
            </code></pre>

                  Copy to Clipboard
                  Описание
                  Инициализатор объекта это выражение, которое описывает инициализацию Object. Объекты состоят из
                  свойств,
                  которые используются для описания объекта. Значения свойств объектов могут содержать как примитивные
                  типы
                  данных, так и другие объекты.

                  Создание объектов
                  Пустой объект без свойств может быть создан следующим образом:
                  <div>
                    var object = {};
                    Copy to Clipboard
                    Однако, преимущество литеральной или инициирующей нотации это возможность быстро создавать объекты
                    со
                    свойствами внутри фигурных скобок. Создаётся простой список пар ключ: значение, разделённых запятой.
                    Следующий код создаёт объект с тремя парами значений и ключи это "foo", "age" и "baz". Значения этих
                    ключей строка "bar", число 42 и другой объект.

                    var object = {
                    foo: 'bar',
                    age: 42,
                    baz: {myProp: 12}
                    }
                  </div>
                  Copy to Clipboard
                  Доступность свойств
                  После того, как создали объект, вы, вероятно, захотите прочитать или изменить его. Свойства объектов
                  могут
                  быть получены при помощи точечной нотации или квадратных скобок. Смотрите property accessors для
                  детальной
                  информации.

                  object.foo; // "bar"
                  object['age']; // 42

                  object.foo = 'baz';
                  Copy to Clipboard
                  Определение свойств
                  Мы уже рассмотрели, как объявить свойства, используя синтаксис инициализации. Зачастую, в коде
                  появляются
                  свойства, которые вы захотите поместить в объект. Вы увидите следующий код:

                  var a = 'foo',
                  b = 42,
                  c = {};

                  var o = {
                  a: a,
                  b: b,
                  c: c
                  };
                  Copy to Clipboard
                  С ECMAScript 2015 появилась короткая нотация, способная достичь того же:

                  var a = 'foo',
                  b = 42,
                  c = {};

                  // Сокращение имён свойств (ES2015)
                  var o = {a, b, c};

                  // Иначе говоря,
                  console.log((o.a === {a}.a)); // true
                  Copy to Clipboard
                  Повторение имён свойств
                  Когда используются одинаковые имена свойств, второе свойство перезапишет первое.

                  var a = {x: 1, x: 2};
                  console.log(a); // {x: 2}
                  Copy to Clipboard
                  В строгом режиме ECMAScript 5, повторение имён свойств будет воспринято как SyntaxError. С введением
                  вычисляемых имён свойств и появлением возможности создавать дубликаты во время выполнения кода,
                  ECMAScript
                  2015 убрал это ограничение.

                  function haveES2015DuplicatePropertySemantics() {
                  'use strict';
                  try {
                  ({prop: 1, prop: 2});

                  // Не будет ошибки, повторение имён доступно в строгом режиме
                  return true;
                  } catch(e) {
                  // Будет ошибка, дубликаты запрещены в строгом режиме
                  return false;
                  }
                  }
                  Copy to Clipboard
                  <div id="two">
                    Описание методов
                    Свойство объекта также может ссылаться на function, getter или setter.
                  </div>
                  var o = {
                  property: function ([parameters]) {},
                  get property() {},
                  set property(value) {}
                  };
                  Copy to Clipboard
                  В ECMAScript 2015, доступна короткая нотация, поэтому слово "function" более не обязательно.

                  // Сокращение имён методов (ES2015)
                  var o = {
                  property([parameters]) {},
                  *generator() {}
                  };
                  Copy to Clipboard
                  В ECMAScript 2015 есть способ кратко объявить свойства, чьими значениями являются генераторы функций:

                  var o = {
                  *generator() {
                  ...........
                  }
                  };
                  Copy to Clipboard
                  Что эквивалентно следующей ES5-подобной нотации (но отметьте, что ECMAScript 5 не содержит
                  генераторов):

                  var o = {
                  generator: function* () {
                  ...........
                  }
                  };
                  Copy to Clipboard
                  Для большей информации и примеров смотри method definitions.

                  Вычисляемые имена свойств
                  Начиная с ECMAScript 2015, синтаксис объявления объектов также поддерживает вычисляемые имена свойств.
                  Это
                  позволяет добавлять в скобки [] выражение, которое будет вычислено, как имя свойства. Это похоже на
                  скобочную нотацию синтаксиса property accessor, которую вы, вероятно, уже использовали, чтобы
                  прочитать и
                  задать свойство. Теперь можно использовать аналогичный способ с литеральными объектами:

                  // Вычисляемое имя свойства (ES2015)
                  var i = 0;
                  var a = {
                  ['foo' + ++i]: i,
                  ['foo' + ++i]: i,
                  ['foo' + ++i]: i
                  };

                  console.log(a.foo1); // 1
                  console.log(a.foo2); // 2
                  console.log(a.foo3); // 3

                  var param = 'size';
                  var config = {
                  [param]: 12,
                  ['mobile' + param.charAt(0).toUpperCase() + param.slice(1)]: 4
                  };

                  console.log(config); // {size: 12, mobileSize: 4}
                  Copy to Clipboard
                  Spread-свойства
                  Rest/Spread свойство ECMAScript предлагает (stage 3) добавлять spread свойства в литеральную нотацию.
                  Оно
                  копирует собственные перечисляемые свойства из представленного объекта в новый.

                  Поверхностное копирование (исключая prototype) или слияние объектов теперь возможно с помощью более
                  короткого синтаксиса, чем Object.assign().

                  var obj1 = { foo: 'bar', x: 42 };
                  var obj2 = { foo: 'baz', y: 13 };

                  var clonedObj = { ...obj1 };
                  // Объект { foo: "bar", x: 42 }

                  var mergedObj = { ...obj1, ...obj2 };
                  // Объект { foo: "baz", x: 42, y: 13 }
                  Copy to Clipboard
                  Заметьте, что Object.assign() вызывает setters, тогда как оператор spread нет.

                  <div id="thr">
                    Изменение Prototype
                    Объявление свойства в виде __proto__: value или "__proto__": value не создаст свойства с именем
                    __proto__. Вместо этого, если предоставляемое значение объект или null, оно заменит [[Prototype]]
                    создаваемого объекта на это значение. (Если значение не объект или null, объект не изменится.)
                  </div>
                  var obj1 = {};
                  assert(Object.getPrototypeOf(obj1) === Object.prototype);

                  var obj2 = {__proto__: null};
                  assert(Object.getPrototypeOf(obj2) === null);

                  var protoObj = {};
                  var obj3 = {'__proto__': protoObj};
                  assert(Object.getPrototypeOf(obj3) === protoObj);

                  var obj4 = {__proto__: 'not an object or null'};
                  assert(Object.getPrototypeOf(obj4) === Object.prototype);
                  assert(!obj4.hasOwnProperty('__proto__'));
                  Copy to Clipboard
                  Только одно изменение prototype разрешено через литеральное объявление объекта: несколько изменений
                  prototype вызовут синтаксическую ошибку.

                  Объявление свойства не через "двоеточие" не изменит значения prototype: это описание будет выглядеть
                  идентично такому же объявлению свойства с использованием любого другого имени.

                  var __proto__ = 'variable';

                  var obj1 = {__proto__};
                  assert(Object.getPrototypeOf(obj1) === Object.prototype);
                  assert(obj1.hasOwnProperty('__proto__'));
                  assert(obj1.__proto__ === 'variable');

                  var obj2 = {__proto__() { return 'hello'; }};
                  assert(obj2.__proto__() === 'hello');

                  var obj3 = {['__prot' + 'o__']: 17};
                  assert(obj3.__proto__ === 17);
                  Copy to Clipboard
                  Литеральная нотация vs JSON
                  Литеральная нотация не то же самое, что и JavaScript Object Notation (JSON). Хотя они и выглядят
                  аналогично, существует разница между ними:

                  JSON позволяет объявление свойств только с помощью синтаксиса "property": value. Имя свойства должно
                  быть
                  заключено в двойные кавычки и объявление не может быть сокращено.
                  В JSON значения могут быть только строками, числами, массивами, true, false, null или другими (JSON)
                  объектами.
                  Значения-функции (смотри "Методы" выше) не м
              </div>
            </div>
            <div class="accordion-item">
              <button id="accordion-button-2" aria-expanded="false"><span
                  class="accordion-title">Конструктор</span><span class="icon" aria-hidden="true"></span></button>
              <div class="accordion-content">
                <p>Объекты могут быть инициализированы с помощью new Object(), Object.create() или литеральной
                  (инициирующей) нотации. Инициализатор объекта это разделённый запятыми список ноль или более пар имён
                  свойств и ассоциируемых с ними значений, заключённых в фигурные скобки ({}).

                  Синтаксис
                  var o = {};
                  var o = {a: 'foo', b: 42, c: {}};

                  var a = 'foo', b = 42, c = {};
                  var o = {a: a, b: b, c: c};

                  var o = {
                  property: function ([parameters]) {},
                  get property() {},
                  set property(value) {}
                  };
                  Copy to Clipboard
                  Новая нотация в ECMAScript 2015
                  Пожалуйста, просмотрите таблицу поддержки этих нотаций. В неподдерживаемом окружении, эти нотации
                  приведут
                  к синтаксической ошибке.

                  // Сокращение имён свойств (ES2015)
                  var a = 'foo', b = 42, c = {};
                  var o = {a, b, c};

                  // Сокращение имён методов (ES2015)
                  var o = {
                  property([parameters]) {}
                  };

                  // Вычисление имён свойств (ES2015)
                  var prop = 'foo';
                  var o = {
                  [prop]: 'hey',
                  ['b' + 'ar']: 'there'
                  };
                  Copy to Clipboard
                  Описание
                  Инициализатор объекта это выражение, которое описывает инициализацию Object. Объекты состоят из
                  свойств,
                  которые используются для описания объекта. Значения свойств объектов могут содержать как примитивные
                  типы
                  данных, так и другие объекты.

                  Создание объектов
                  Пустой объект без свойств может быть создан следующим образом:

                  var object = {};
                  Copy to Clipboard
                  Однако, преимущество литеральной или инициирующей нотации это возможность быстро создавать объекты со
                  свойствами внутри фигурных скобок. Создаётся простой список пар ключ: значение, разделённых запятой.
                  Следующий код создаёт объект с тремя парами значений и ключи это "foo", "age" и "baz". Значения этих
                  ключей строка "bar", число 42 и другой объект.

                  var object = {
                  foo: 'bar',
                  age: 42,
                  baz: {myProp: 12}
                  }
                  Copy to Clipboard
                  Доступность свойств
                  После того, как создали объект, вы, вероятно, захотите прочитать или изменить его. Свойства объектов
                  могут
                  быть получены при помощи точечной нотации или квадратных скобок. Смотрите property accessors для
                  детальной
                  информации.

                  object.foo; // "bar"
                  object['age']; // 42

                  object.foo = 'baz';
                  Copy to Clipboard
                  Определение свойств
                  Мы уже рассмотрели, как объявить свойства, используя синтаксис инициализации. Зачастую, в коде
                  появляются
                  свойства, которые вы захотите поместить в объект. Вы увидите следующий код:

                  var a = 'foo',
                  b = 42,
                  c = {};

                  var o = {
                  a: a,
                  b: b,
                  c: c
                  };
                  Copy to Clipboard
                  С ECMAScript 2015 появилась короткая нотация, способная достичь того же:

                  var a = 'foo',
                  b = 42,
                  c = {};

                  // Сокращение имён свойств (ES2015)
                  var o = {a, b, c};

                  // Иначе говоря,
                  console.log((o.a === {a}.a)); // true
                  Copy to Clipboard
                  Повторение имён свойств
                  Когда используются одинаковые имена свойств, второе свойство перезапишет первое.

                  var a = {x: 1, x: 2};
                  console.log(a); // {x: 2}
                  Copy to Clipboard
                  В строгом режиме ECMAScript 5, повторение имён свойств будет воспринято как SyntaxError. С введением
                  вычисляемых имён свойств и появлением возможности создавать дубликаты во время выполнения кода,
                  ECMAScript
                  2015 убрал это ограничение.

                  function haveES2015DuplicatePropertySemantics() {
                  'use strict';
                  try {
                  ({prop: 1, prop: 2});

                  // Не будет ошибки, повторение имён доступно в строгом режиме
                  return true;
                  } catch(e) {
                  // Будет ошибка, дубликаты запрещены в строгом режиме
                  return false;
                  }
                  }
                  Copy to Clipboard
                  Описание методов
                  Свойство объекта также может ссылаться на function, getter или setter.

                  var o = {
                  property: function ([parameters]) {},
                  get property() {},
                  set property(value) {}
                  };
                  Copy to Clipboard
                  В ECMAScript 2015, доступна короткая нотация, поэтому слово "function" более не обязательно.

                  // Сокращение имён методов (ES2015)
                  var o = {
                  property([parameters]) {},
                  *generator() {}
                  };
                  Copy to Clipboard
                  В ECMAScript 2015 есть способ кратко объявить свойства, чьими значениями являются генераторы функций:

                  var o = {
                  *generator() {
                  ...........
                  }
                  };
                  Copy to Clipboard
                  Что эквивалентно следующей ES5-подобной нотации (но отметьте, что ECMAScript 5 не содержит
                  генераторов):

                  var o = {
                  generator: function* () {
                  ...........
                  }
                  };
                  Copy to Clipboard
                  Для большей информации и примеров смотри method definitions.

                  Вычисляемые имена свойств
                  Начиная с ECMAScript 2015, синтаксис объявления объектов также поддерживает вычисляемые имена свойств.
                  Это
                  позволяет добавлять в скобки [] выражение, которое будет вычислено, как имя свойства. Это похоже на
                  скобочную нотацию синтаксиса property accessor, которую вы, вероятно, уже использовали, чтобы
                  прочитать и
                  задать свойство. Теперь можно использовать аналогичный способ с литеральными объектами:

                  // Вычисляемое имя свойства (ES2015)
                  var i = 0;
                  var a = {
                  ['foo' + ++i]: i,
                  ['foo' + ++i]: i,
                  ['foo' + ++i]: i
                  };

                  console.log(a.foo1); // 1
                  console.log(a.foo2); // 2
                  console.log(a.foo3); // 3

                  var param = 'size';
                  var config = {
                  [param]: 12,
                  ['mobile' + param.charAt(0).toUpperCase() + param.slice(1)]: 4
                  };

                  console.log(config); // {size: 12, mobileSize: 4}
                  Copy to Clipboard
                  Spread-свойства
                  Rest/Spread свойство ECMAScript предлагает (stage 3) добавлять spread свойства в литеральную нотацию.
                  Оно
                  копирует собственные перечисляемые свойства из представленного объекта в новый.

                  Поверхностное копирование (исключая prototype) или слияние объектов теперь возможно с помощью более
                  короткого синтаксиса, чем Object.assign().

                  var obj1 = { foo: 'bar', x: 42 };
                  var obj2 = { foo: 'baz', y: 13 };

                  var clonedObj = { ...obj1 };
                  // Объект { foo: "bar", x: 42 }

                  var mergedObj = { ...obj1, ...obj2 };
                  // Объект { foo: "baz", x: 42, y: 13 }
                  Copy to Clipboard
                  Заметьте, что Object.assign() вызывает setters, тогда как оператор spread нет.

                  Изменение Prototype
                  Объявление свойства в виде __proto__: value или "__proto__": value не создаст свойства с именем
                  __proto__.
                  Вместо этого, если предоставляемое значение объект или null, оно заменит [[Prototype]] создаваемого
                  объекта на это значение. (Если значение не объект или null, объект не изменится.)

                  var obj1 = {};
                  assert(Object.getPrototypeOf(obj1) === Object.prototype);

                  var obj2 = {__proto__: null};
                  assert(Object.getPrototypeOf(obj2) === null);

                  var protoObj = {};
                  var obj3 = {'__proto__': protoObj};
                  assert(Object.getPrototypeOf(obj3) === protoObj);

                  var obj4 = {__proto__: 'not an object or null'};
                  assert(Object.getPrototypeOf(obj4) === Object.prototype);
                  assert(!obj4.hasOwnProperty('__proto__'));
                  Copy to Clipboard
                  Только одно изменение prototype разрешено через литеральное объявление объекта: несколько изменений
                  prototype вызовут синтаксическую ошибку.

                  Объявление свойства не через "двоеточие" не изменит значения prototype: это описание будет выглядеть
                  идентично такому же объявлению свойства с использованием любого другого имени.

                  var __proto__ = 'variable';

                  var obj1 = {__proto__};
                  assert(Object.getPrototypeOf(obj1) === Object.prototype);
                  assert(obj1.hasOwnProperty('__proto__'));
                  assert(obj1.__proto__ === 'variable');

                  var obj2 = {__proto__() { return 'hello'; }};
                  assert(obj2.__proto__() === 'hello');

                  var obj3 = {['__prot' + 'o__']: 17};
                  assert(obj3.__proto__ === 17);
                  Copy to Clipboard
                  Литеральная нотация vs JSON
                  Литеральная нотация не то же самое, что и JavaScript Object Notation (JSON). Хотя они и выглядят
                  аналогично, существует разница между ними:

                  JSON позволяет объявление свойств только с помощью синтаксиса "property": value. Имя свойства должно
                  быть
                  заключено в двойные кавычки и объявление не может быть сокращено.
                  В JSON значения могут быть только строками, числами, массивами, true, false, null или другими (JSON)
                  объектами.
                  Значения-функции (смотри "Методы" выше) не м.</p>
              </div>
            </div>
            <div class="accordion-item">
              <button id="accordion-button-3" aria-expanded="false"><span class="accordion-title">Will we ever discover
                  aliens?</span><span class="icon" aria-hidden="true"></span></button>
              <div class="accordion-content">
                <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore
                  et
                  dolore magna aliqua. Elementum sagittis vitae et leo duis ut. Ut tortor pretium viverra suspendisse
                  potenti.</p>
              </div>
            </div>
            <div class="accordion-item">
              <button id="accordion-button-4" aria-expanded="false"><span class="accordion-title">How much does the
                  Earth
                  weigh?</span><span class="icon" aria-hidden="true"></span></button>
              <div class="accordion-content">
                <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore
                  et
                  dolore magna aliqua. Elementum sagittis vitae et leo duis ut. Ut tortor pretium viverra suspendisse
                  potenti.</p>
              </div>
            </div>
            <div class="accordion-item">
              <button id="accordion-button-5" aria-expanded="false"><span class="accordion-title">How do airplanes stay
                  up?</span><span class="icon" aria-hidden="true"></span></button>
              <div class="accordion-content">
                <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore
                  et
                  dolore magna aliqua. Elementum sagittis vitae et leo duis ut. Ut tortor pretium viverra suspendisse
                  potenti.</p>
              </div>
            </div>
          </div>
        </div>

      </div>
      <!-- end theory block 3 -->
    </div>

    <!-- theories end  -->



    <!-- end theory block  -->
  </div>



  <script src="pages/header.js"></script>
  <script src="helpers/main.js"></script>
  <!-- <script src="helpers/pens-constructor.js"></script> -->
  <script src="helpers/theory-constructor.js"></script>
  <script src="Pens-JSON/index.js"></script>
  <script src="pages/theory-pages/body.js"></script>

</body>

</html>